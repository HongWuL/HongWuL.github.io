<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>brpc实现原理(1)-DoublyBufferedData</title>
      <link href="/2024/03/22/brpc%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-1-DoublyBufferedData/"/>
      <url>/2024/03/22/brpc%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-1-DoublyBufferedData/</url>
      
        <content type="html"><![CDATA[<h1 id="DoublyBufferedData"><a href="#DoublyBufferedData" class="headerlink" title="DoublyBufferedData"></a>DoublyBufferedData</h1><p><strong>DoublyBufferedData</strong>(简称DBD)是一个brpc中实现的<strong>双缓冲区</strong>+<strong>Thread Local缓存</strong>的数据结构，主要用于<strong>多读少写</strong>的场景，如负载均衡场景：每次请求都需要选择合适的下游节点，但下游服务器列表更新不可能很频繁。本文以brpc release-1.2.0的DBD代码为主进行分析，因为这个版本的代码比较简洁，后续版本整体实现思想没变，只是针对一些极端场景做了改进，如解决pthread_key存在上限的问题，bthread suspended问题等。</p><p><strong>我将brpc里的DBD代码单独提取了出来，将brpc相关依赖换成了c++的STL库函数，写了完整且纤细的注释，并添加了一个模拟RoundRobin负载均衡的example，以方便理解这一数据结构，具体见<a href="https://github.com/HongWuL/CppCodeNotes/tree/main/Containers/DoublyBufferedData">github</a>。</strong></p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>DBD主要存储两类数据:</p><ul><li><code>&lt;T&gt;</code>类型的双缓冲数据，一般为c++容器里的数据如vector。该数据有两个副本，叫做前台数据(fg)和后台数据(bg)。读操作读的是前台数据，修改操作之在后台数据上进行。</li><li><code>&lt;TLS&gt;</code>类型的Thread Local缓存。该结构旨在存储专属于本线程的数据，以减少线程之间的数据竞争。</li></ul><p>DBD的主要结构如下:</p><ul><li>原子变量<code>_index</code>指向的是双缓冲结构的前台数据，可能是<code>_data[0]</code>,也可能是<code>_data[1]</code>。</li><li>线程通过<code>_wapper_key</code>的<code>pthread_setspecific</code>与某一Wrapper绑定，然后通过<code>pthread_getspecific</code> 获取当前线程绑定的<code>Wrapper*</code>，进而获取TLS数据。</li></ul><p>DBD示意图：</p><p><img src="https://pic.imgdb.cn/item/660020819f345e8d037b0205.png" alt="dbd1"></p><blockquote><p>ps: 所有的<code>Wrapper*</code>在所有线程中都是可见的，只是实践过程中通过<code>_wapper_key</code> 获得了当前线程绑定的<code>Wrapper*</code> 。</p></blockquote><h2 id="读-改操作"><a href="#读-改操作" class="headerlink" title="读&amp;改操作"></a>读&amp;改操作</h2><h3 id="Read-ScopedPtr-ptr"><a href="#Read-ScopedPtr-ptr" class="headerlink" title="Read(ScopedPtr* ptr)"></a>Read(ScopedPtr* ptr)</h3><p>ScopedPtr用于提取核心数据：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ScopedPtr</span> &#123;</span><br><span class="line"><span class="comment">// 类似于一个代理，通过该类获取缓冲数据和TLS数据</span></span><br><span class="line"><span class="comment">// _data指向存储的数据</span></span><br><span class="line"><span class="comment">// _w指向Wrapper包含的TLS数据</span></span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">DoublyBufferedData</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ScopedPtr</span>() : _data(<span class="literal">NULL</span>), _w(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">ScopedPtr</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (_w) &#123;</span><br><span class="line">            _w-&gt;<span class="built_in">EndRead</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> T* <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _data; &#125;</span><br><span class="line">    <span class="type">const</span> T&amp; <span class="keyword">operator</span>*() <span class="type">const</span> &#123; <span class="keyword">return</span> *_data; &#125;</span><br><span class="line">    <span class="type">const</span> T* <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123; <span class="keyword">return</span> _data; &#125;</span><br><span class="line">    <span class="function">TLS&amp; <span class="title">tls</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _w-&gt;<span class="built_in">user_tls</span>(); &#125;   <span class="comment">//返回TLS数据</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> T* _data; <span class="comment">//所有线程共享的数据（即双缓冲数据）</span></span><br><span class="line">    Wrapper* _w;    <span class="comment">//Thread local数据</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>读操作是将前台数据以及当前线程的TLS数据读到ptr中。</p><p>读的过程中每个Wrapper会加一个锁，但由于Wrapper和thread绑定，因此这个锁竞争很小。但是也不是不会有竞争，什么情况下会产生竞争呢？当其Modify线程修改完后台时，想要切换前后台，此时会产生一个很小的竞争，具体情况在后面的<strong>时序图</strong>中展示。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> TLS&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DoublyBufferedData</span>&lt;T, TLS&gt;::Wrapper</span><br><span class="line">    : <span class="keyword">public</span> DoublyBufferedDataWrapperBase&lt;T, TLS&gt; &#123;</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">DoublyBufferedData</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Wrapper</span><span class="params">(DoublyBufferedData* c)</span> : _control(c) &#123;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">Wrapper</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (_control != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            _control-&gt;<span class="built_in">RemoveWrapper</span>(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// _mutex will be locked by the calling pthread and DoublyBufferedData.</span></span><br><span class="line">    <span class="comment">// Most of the time, no modifications are done, so the mutex is</span></span><br><span class="line">    <span class="comment">// uncontended and fast.</span></span><br><span class="line">    <span class="comment">// 在同一个线程中使用，锁基本无竞争</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">BeginRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        _mutex.<span class="built_in">lock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">EndRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        _mutex.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">WaitReadDone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 等待读结束，以便切换fg和bg</span></span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(_mutex)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    DoublyBufferedData* _control;  </span><br><span class="line">    std::mutex _mutex;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Modify"><a href="#Modify" class="headerlink" title="Modify"></a>Modify</h3><p>根据传入的函数<code>Fn</code>修改双缓冲的数据。</p><p>为了减少锁竞争，先修改后台数据，修改过程中读前台数据不受影响。当修改完数据之后，切换前后台，即更改<code>_index</code> 的值。在修改的过程中，有的线程可能旧前台数据还没读完，因此还不能马上修改旧前台(新后台)，因此通过尝试获取其它读线程的锁(也就是上面的<code>_mutex</code>)，来确认所有线程都读完旧前台了，那么就可以对旧前台进行同样的修改操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> TLS&gt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Fn&gt;</span><br><span class="line"><span class="type">size_t</span> DoublyBufferedData&lt;T, TLS&gt;::<span class="built_in">Modify</span>(Fn&amp; fn) &#123;</span><br><span class="line">    <span class="comment">// _modify_mutex sequences modifications. Using a separate mutex rather</span></span><br><span class="line">    <span class="comment">// than _wrappers_mutex is to avoid blocking threads calling</span></span><br><span class="line">    <span class="comment">// AddWrapper() or RemoveWrapper() too long. Most of the time, modifications</span></span><br><span class="line">    <span class="comment">// are done by one thread, contention should be negligible.</span></span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(_modify_mutex)</span></span>;</span><br><span class="line">    <span class="type">int</span> bg_index = !_index.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">    <span class="comment">// background instance is not accessed by other threads, being safe to</span></span><br><span class="line">    <span class="comment">// modify.</span></span><br><span class="line">    <span class="comment">// 修改bg</span></span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> ret = <span class="built_in">fn</span>(_data[bg_index]);</span><br><span class="line">    <span class="keyword">if</span> (!ret) &#123;</span><br><span class="line">        <span class="comment">// 修改失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Publish, flip background and foreground.</span></span><br><span class="line">    <span class="comment">// The release fence matches with the acquire fence in UnsafeRead() to</span></span><br><span class="line">    <span class="comment">// make readers which just begin to read the new foreground instance see</span></span><br><span class="line">    <span class="comment">// all changes made in fn.</span></span><br><span class="line">    <span class="comment">// 切换前后台</span></span><br><span class="line">    _index.<span class="built_in">store</span>(bg_index, std::memory_order_release);</span><br><span class="line">    bg_index = !bg_index;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Wait until all threads finishes current reading. When they begin next</span></span><br><span class="line">    <span class="comment">// read, they should see updated _index.</span></span><br><span class="line">    <span class="comment">// 等待每个旧的前台读完，认为是前台看到新的前台了</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(_wrappers_mutex)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; _wrappers.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            _wrappers[i]-&gt;<span class="built_in">WaitReadDone</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 修改新后台(旧前台)</span></span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> ret2 = <span class="built_in">fn</span>(_data[bg_index]);</span><br><span class="line">    <span class="keyword">return</span> ret2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Read-Modify示意图"><a href="#Read-Modify示意图" class="headerlink" title="Read &amp;Modify示意图"></a>Read &amp;Modify示意图</h4><p><img src="https://pic.imgdb.cn/item/660020829f345e8d037b072b.pngg" alt="dbd2"></p><h4 id="Read-Modify锁时序图"><a href="#Read-Modify锁时序图" class="headerlink" title="Read &amp;Modify锁时序图"></a>Read &amp;Modify锁时序图</h4><p>如下图所示，thread1读旧前台还没结束，modify线程thread2会等待thread1读完才会对旧前台进行修改。</p><p><img src="https://pic.imgdb.cn/item/660020829f345e8d037b0c50.png" alt="dbd3"></p>]]></content>
      
      
      
        <tags>
            
            <tag> c++,brpc,微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/02/29/hello-world/"/>
      <url>/2024/02/29/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
